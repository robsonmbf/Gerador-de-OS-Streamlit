import streamlit as st
import pandas as pd
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import zipfile
from io import BytesIO
import time
import re
import sys
import os

# Adicionar o diret√≥rio atual ao path para importar m√≥dulos locais
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from database.models import DatabaseManager
from database.auth import AuthManager
from database.user_data import UserDataManager

# --- Configura√ß√£o da P√°gina ---
st.set_page_config(
    page_title="Gerador de Ordens de Servi√ßo (OS)",
    page_icon="üìÑ",
    layout="wide",
)

# --- DEFINI√á√ÉO DE CONSTANTES GLOBAIS ---
UNIDADES_DE_MEDIDA = ["dB(A)", "m/s¬≤", "m/s¬π‚Å∑‚Åµ", "ppm", "mg/m¬≥", "%", "¬∞C", "lx", "cal/cm¬≤", "¬µT", "kV/m", "W/m¬≤", "f/cm¬≥", "N√£o aplic√°vel"]
AGENTES_DE_RISCO = sorted([
    "Ru√≠do (Cont√≠nuo ou Intermitente)", "Ru√≠do (Impacto)", "Vibra√ß√£o de Corpo Inteiro", "Vibra√ß√£o de M√£os e Bra√ßos",
    "Radia√ß√µes Ionizantes", "Radia√ß√µes N√£o-Ionizantes", "Frio", "Calor", "Press√µes Anormais", "Umidade", "Poeiras", 
    "Fumos", "N√©voas", "Neblinas", "Gases", "Vapores", "Produtos Qu√≠micos em Geral", "V√≠rus", "Bact√©rias", 
    "Protozo√°rios", "Fungos", "Parasitas", "Bacilos"
])
CATEGORIAS_RISCO = {'fisico': 'üî• F√≠sicos', 'quimico': '‚öóÔ∏è Qu√≠micos', 'biologico': 'ü¶† Biol√≥gicos', 'ergonomico': 'üèÉ Ergon√¥micos', 'acidente': '‚ö†Ô∏è Acidentes'}

# --- Inicializa√ß√£o dos Gerenciadores ---
@st.cache_resource
def init_managers():
    db_manager = DatabaseManager()
    auth_manager = AuthManager(db_manager)
    user_data_manager = UserDataManager(db_manager)
    return db_manager, auth_manager, user_data_manager

db_manager, auth_manager, user_data_manager = init_managers()

# --- CSS PERSONALIZADO ---
st.markdown("""
<style>
    [data-testid="stSidebar"] {
        display: none;
    }
    .main-header {
        text-align: center;
        padding-bottom: 20px;
    }
    .auth-container {
        max-width: 400px;
        margin: 0 auto;
        padding: 2rem;
        border: 1px solid #ddd;
        border-radius: 10px;
        background-color: #f9f9f9;
    }
    .user-info {
        background-color: #262730; 
        color: white;            
        padding: 1rem;
        border-radius: 5px;
        margin-bottom: 1rem;
        border: 1px solid #3DD56D; 
    }
</style>
""", unsafe_allow_html=True)


# --- FUN√á√ïES DE AUTENTICA√á√ÉO E L√ìGICA DE NEG√ìCIO ---
def show_login_page():
    st.markdown("""<div class="main-header"><h1>üîê Acesso ao Sistema</h1><p>Fa√ßa login ou registre-se para acessar o Gerador de OS</p></div>""", unsafe_allow_html=True)
    tab1, tab2 = st.tabs(["Login", "Registro"])
    with tab1:
        with st.form("login_form"):
            email = st.text_input("Email", placeholder="seu@email.com")
            password = st.text_input("Senha", type="password")
            if st.form_submit_button("Entrar", use_container_width=True):
                if email and password:
                    success, message, session_data = auth_manager.login_user(email, password)
                    if success:
                        st.session_state.authenticated = True
                        st.session_state.user_data = session_data
                        st.session_state.user_data_loaded = False 
                        st.success(message)
                        st.rerun()
                    else:
                        st.error(message)
                else:
                    st.error("Por favor, preencha todos os campos")
    with tab2:
        with st.form("register_form"):
            reg_email = st.text_input("Email", placeholder="seu@email.com", key="reg_email")
            reg_password = st.text_input("Senha", type="password", key="reg_password")
            reg_password_confirm = st.text_input("Confirmar Senha", type="password")
            if st.form_submit_button("Registrar", use_container_width=True):
                if reg_email and reg_password and reg_password_confirm:
                    if reg_password != reg_password_confirm:
                        st.error("As senhas n√£o coincidem")
                    else:
                        success, message = auth_manager.register_user(reg_email, reg_password)
                        if success:
                            st.success(message)
                            st.info("Agora voc√™ pode fazer login com suas credenciais")
                        else:
                            st.error(message)
                else:
                    st.error("Por favor, preencha todos os campos")

def check_authentication():
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
    if 'user_data' not in st.session_state:
        st.session_state.user_data = None
    if st.session_state.authenticated and st.session_state.user_data:
        session_token = st.session_state.user_data.get('session_token')
        if session_token:
            is_valid, _ = auth_manager.validate_session(session_token)
            if not is_valid:
                st.session_state.authenticated = False
                st.session_state.user_data = None
                st.rerun()

def logout_user():
    if st.session_state.user_data and st.session_state.user_data.get('session_token'):
        auth_manager.logout_user(st.session_state.user_data['session_token'])
    st.session_state.authenticated = False
    st.session_state.user_data = None
    st.session_state.user_data_loaded = False
    st.rerun()

def show_user_info():
    if st.session_state.get('authenticated'):
        user_email = st.session_state.user_data.get('email', 'N/A')
        col1, col2 = st.columns([3, 1])
        with col1:
            st.markdown(f'<div class="user-info">üë§ <strong>Usu√°rio:</strong> {user_email}</div>', unsafe_allow_html=True)
        with col2:
            if st.button("Sair", type="secondary"):
                logout_user()

def init_user_session_state():
    if st.session_state.get('authenticated') and not st.session_state.get('user_data_loaded'):
        user_id = st.session_state.user_data.get('user_id')
        if user_id:
            st.session_state.medicoes_adicionadas = user_data_manager.get_user_measurements(user_id)
            st.session_state.epis_adicionados = user_data_manager.get_user_epis(user_id)
            st.session_state.riscos_manuais_adicionados = user_data_manager.get_user_manual_risks(user_id)
            st.session_state.user_data_loaded = True
    
    if 'medicoes_adicionadas' not in st.session_state:
        st.session_state.medicoes_adicionadas = []
    if 'epis_adicionados' not in st.session_state:
        st.session_state.epis_adicionados = []
    if 'riscos_manuais_adicionados' not in st.session_state:
        st.session_state.riscos_manuais_adicionados = []
    if 'cargos_concluidos' not in st.session_state:
        st.session_state.cargos_concluidos = set()

def normalizar_texto(texto):
    if not isinstance(texto, str): return ""
    return re.sub(r'[\s\W_]+', '', texto.lower().strip())

def mapear_e_renomear_colunas_funcionarios(df):
    df_copia = df.copy()
    mapeamento = {
        'nome_do_funcionario': ['nomedofuncionario', 'nome', 'funcionario', 'funcion√°rio', 'colaborador', 'nomecompleto'],
        'funcao': ['funcao', 'fun√ß√£o', 'cargo'],
        'data_de_admissao': ['datadeadmissao', 'dataadmissao', 'admissao', 'admiss√£o'],
        'setor': ['setordetrabalho', 'setor', 'area', '√°rea', 'departamento'],
        'descricao_de_atividades': ['descricaodeatividades', 'atividades', 'descricaoatividades', 'descri√ß√£odeatividades', 'tarefas', 'descricaodastarefas'],
        'empresa': ['empresa'],
        'unidade': ['unidade']
    }
    colunas_renomeadas = {}
    colunas_df_normalizadas = {normalizar_texto(col): col for col in df_copia.columns}
    for nome_padrao, nomes_possiveis in mapeamento.items():
        for nome_possivel in nomes_possiveis:
            if nome_possivel in colunas_df_normalizadas:
                coluna_original = colunas_df_normalizadas[nome_possivel]
                colunas_renomeadas[coluna_original] = nome_padrao
                break
    df_copia.rename(columns=colunas_renomeadas, inplace=True)
    return df_copia

@st.cache_data
def carregar_planilha(arquivo):
    if arquivo is None: return None
    try:
        return pd.read_excel(arquivo)
    except Exception as e:
        st.error(f"Erro ao ler o ficheiro Excel: {e}")
        return None

@st.cache_data
def obter_dados_pgr():
    data = [
        {'categoria': 'quimico', 'risco': 'Exposi√ß√£o a Produto Qu√≠mico', 'possiveis_danos': 'Irrita√ß√£o/les√£o ocular, na pele e mucosas; Dermatites; Queimadura Qu√≠mica; Intoxica√ß√£o; N√°useas; V√¥mitos.'},
        {'categoria': 'fisico', 'risco': 'Ambiente Artificialmente Frio', 'possiveis_danos': 'Estresse, desconforto, dorm√™ncia, rigidez nas partes com maior intensidade de exposi√ß√£o ao frio, redu√ß√£o da destreza, formigamento, redu√ß√£o da sensibilidade dos dedos e flexibilidade das articula√ß√µes.'},
        {'categoria': 'fisico', 'risco': 'Exposi√ß√£o ao Ru√≠do', 'possiveis_danos': 'Perda Auditiva Induzida pelo Ru√≠do Ocupacional (PAIRO).'},
        {'categoria': 'fisico', 'risco': 'Vibra√ß√µes Localizadas (m√£o/bra√ßo)', 'possiveis_danos': 'Altera√ß√µes articulares e vasomotoras.'},
        {'categoria': 'fisico', 'risco': 'Vibra√ß√£o de Corpo Inteiro (AREN/VDVR)', 'possiveis_danos': 'Altera√ß√µes no sistema digestivo, sistema musculoesquel√©tico, sistema nervoso, altera√ß√µes na vis√£o, enjoos, n√°useas, palidez.'},
        {'categoria': 'fisico', 'risco': 'Radia√ß√µes Ionizantes', 'possiveis_danos': 'C√¢ncer, muta√ß√µes gen√©ticas, queimaduras.'},
        {'categoria': 'fisico', 'risco': 'Radia√ß√µes N√£o Ionizantes', 'possiveis_danos': 'Queimaduras, les√µes oculares, c√¢ncer de pele.'},
        {'categoria': 'fisico', 'risco': 'Press√µes Anormais', 'possiveis_danos': 'Doen√ßa descompressiva, barotrauma.'},
        {'categoria': 'fisico', 'risco': 'Umidade', 'possiveis_danos': 'Doen√ßas respirat√≥rias, dermatites, micoses.'},
        {'categoria': 'fisico', 'risco': 'Calor', 'possiveis_danos': 'Desidrata√ß√£o, insola√ß√£o, c√£ibras, exaust√£o, interma√ß√£o.'},
        {'categoria': 'fisico', 'risco': 'Frio', 'possiveis_danos': 'Hipotermia, congelamento, doen√ßas respirat√≥rias.'},
        {'categoria': 'quimico', 'risco': 'Poeiras', 'possiveis_danos': 'Pneumoconioses (silicose, asbestose), irrita√ß√£o respirat√≥ria.'},
        {'categoria': 'quimico', 'risco': 'Fumos', 'possiveis_danos': 'Doen√ßas respirat√≥rias (febre dos fumos met√°licos), intoxica√ß√µes.'},
        {'categoria': 'quimico', 'risco': 'N√©voas', 'possiveis_danos': 'Irrita√ß√£o respirat√≥ria, dermatites.'},
        {'categoria': 'quimico', 'risco': 'Gases', 'possiveis_danos': 'Asfixia, intoxica√ß√µes, irrita√ß√£o respirat√≥ria.'},
        {'categoria': 'quimico', 'risco': 'Vapores', 'possiveis_danos': 'Irrita√ß√£o respirat√≥ria, intoxica√ß√µes, dermatites.'},
        {'categoria': 'quimico', 'risco': 'Produtos Qu√≠micos em Geral', 'possiveis_danos': 'Queimaduras, irrita√ß√µes, intoxica√ß√µes, dermatites, c√¢ncer.'},
        {'categoria': 'biologico', 'risco': 'Bact√©rias', 'possiveis_danos': 'Infec√ß√µes, doen√ßas infecciosas (t√©tano, tuberculose).'}, 
        {'categoria': 'biologico', 'risco': 'Fungos', 'possiveis_danos': 'Micoses, alergias, infec√ß√µes respirat√≥rias.'},
        {'categoria': 'biologico', 'risco': 'V√≠rus', 'possiveis_danos': 'Doen√ßas virais (hepatite, HIV), infec√ß√µes.'},
        {'categoria': 'ergonomico', 'risco': 'Levantamento e Transporte Manual de Peso', 'possiveis_danos': 'Les√µes musculoesquel√©ticas, dores na coluna.'},
        {'categoria': 'ergonomico', 'risco': 'Posturas Inadequadas', 'possiveis_danos': 'Dores musculares, les√µes na coluna, LER/DORT.'},
        {'categoria': 'ergonomico', 'risco': 'Repetitividade', 'possiveis_danos': 'LER/DORT, tendinites, s√≠ndrome do t√∫nel do carpo.'},
        {'categoria': 'acidente', 'risco': 'M√°quinas e Equipamentos sem Prote√ß√£o', 'possiveis_danos': 'Amputa√ß√µes, cortes, esmagamentos, prensamentos.'},
        {'categoria': 'acidente', 'risco': 'Eletricidade', 'possiveis_danos': 'Choque el√©trico, queimaduras, fibrila√ß√£o ventricular.'},
        {'categoria': 'acidente', 'risco': 'Trabalho em Altura', 'possiveis_danos': 'Quedas, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Proje√ß√£o de Part√≠culas', 'possiveis_danos': 'Les√µes oculares, cortes na pele.'},
        {'categoria': 'acidente', 'risco': 'Animais pe√ßonhentos', 'possiveis_danos': 'Picadas, mordidas, rea√ß√µes al√©rgicas, infec√ß√µes, dor, incha√ßo, necrose, paralisia, morte.'},
        {'categoria': 'acidente', 'risco': 'Armazenamento inadequado de materiais', 'possiveis_danos': 'Quedas, soterramento, esmagamento, les√µes por esfor√ßo repetitivo.'},
        {'categoria': 'acidente', 'risco': 'Atropelamento', 'possiveis_danos': 'Fraturas, lacera√ß√µes, traumatismos, morte.'},
        {'categoria': 'acidente', 'risco': 'Choque contra objetos', 'possiveis_danos': 'Contus√µes, fraturas, lacera√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Colis√£o', 'possiveis_danos': 'Contus√µes, fraturas, lacera√ß√µes, traumatismos.'},
        {'categoria': 'acidente', 'risco': 'Contato com eletricidade', 'possiveis_danos': 'Choque el√©trico, queimaduras, fibrila√ß√£o ventricular, morte.'},
        {'categoria': 'acidente', 'risco': 'Contato com superf√≠cie quente', 'possiveis_danos': 'Queimaduras de 1¬∫, 2¬∫ ou 3¬∫ grau.'},
        {'categoria': 'acidente', 'risco': 'Contato com superf√≠cie fria', 'possiveis_danos': 'Queimaduras por frio, hipotermia.'},
        {'categoria': 'acidente', 'risco': 'Corte/Lacera√ß√£o', 'possiveis_danos': 'Hemorragia, infec√ß√£o, perda de fun√ß√£o.'},
        {'categoria': 'acidente', 'risco': 'Empilhamento inadequado', 'possiveis_danos': 'Quedas, soterramento, esmagamento.'},
        {'categoria': 'acidente', 'risco': 'Equipamento com defeito/sem manuten√ß√£o', 'possiveis_danos': 'Falha do equipamento, acidentes, les√µes.'},
        {'categoria': 'acidente', 'risco': 'Explos√£o', 'possiveis_danos': 'Queimaduras, traumatismos, proje√ß√£o de fragmentos, morte.'},
        {'categoria': 'acidente', 'risco': 'Inc√™ndio', 'possiveis_danos': 'Queimaduras, inala√ß√£o de fuma√ßa, asfixia, morte.'},
        {'categoria': 'acidente', 'risco': 'Impacto de objetos', 'possiveis_danos': 'Contus√µes, fraturas, lacera√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'M√°quinas e equipamentos sem prote√ß√£o', 'possiveis_danos': 'Amputa√ß√µes, cortes, esmagamentos, prensamentos.'},
        {'categoria': 'acidente', 'risco': 'Manuseio de produtos qu√≠micos sem EPI', 'possiveis_danos': 'Queimaduras qu√≠micas, irrita√ß√µes, intoxica√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Queda de altura', 'possiveis_danos': 'Fraturas, traumatismos, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda em mesmo n√≠vel', 'possiveis_danos': 'Contus√µes, entorses, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Soterramento', 'possiveis_danos': 'Asfixia, traumatismos, morte.'},
        {'categoria': 'acidente', 'risco': 'Ve√≠culos em movimento', 'possiveis_danos': 'Atropelamento, colis√£o, esmagamento, morte.'},
        {'categoria': 'acidente', 'risco': 'Agress√£o f√≠sica', 'possiveis_danos': 'Les√µes corporais, traumatismos, estresse psicol√≥gico.'},
        {'categoria': 'acidente', 'risco': 'Animais (ataque de)', 'possiveis_danos': 'Mordidas, arranh√µes, infec√ß√µes, rea√ß√µes al√©rgicas.'},
        {'categoria': 'acidente', 'risco': 'Desabamento/colapso', 'possiveis_danos': 'Soterramento, esmagamento, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Exposi√ß√£o a temperaturas extremas', 'possiveis_danos': 'Hipotermia, hipertermia, queimaduras, insola√ß√£o.'},
        {'categoria': 'acidente', 'risco': 'Ferramentas manuais (uso inadequado)', 'possiveis_danos': 'Cortes, perfura√ß√µes, contus√µes, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Inc√™ndio/explos√£o', 'possiveis_danos': 'Queimaduras, inala√ß√£o de fuma√ßa, traumatismos, morte.'},
        {'categoria': 'acidente', 'risco': 'Objetos cortantes/perfurocortantes', 'possiveis_danos': 'Cortes, perfura√ß√µes, lacera√ß√µes, infec√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Produtos qu√≠micos (derramamento/vazamento)', 'possiveis_danos': 'Queimaduras qu√≠micas, irrita√ß√µes, intoxica√ß√µes, problemas respirat√≥rios.'},
        {'categoria': 'acidente', 'risco': 'Queda de objetos', 'possiveis_danos': 'Impacto, contus√µes, fraturas, traumatismos.'},
        {'categoria': 'acidente', 'risco': 'Ru√≠do excessivo', 'possiveis_danos': 'Perda auditiva, zumbido, estresse.'},
        {'categoria': 'acidente', 'risco': 'Superf√≠cies escorregadias/irregulares', 'possiveis_danos': 'Quedas, contus√µes, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Trabalho em altura', 'possiveis_danos': 'Quedas, fraturas, traumatismos, morte.'},
        {'categoria': 'acidente', 'risco': 'Trabalho em espa√ßo confinado', 'possiveis_danos': 'Asfixia, intoxica√ß√£o, desmaio, morte.'},
        {'categoria': 'acidente', 'risco': 'Ve√≠culos e m√°quinas (opera√ß√£o)', 'possiveis_danos': 'Atropelamento, colis√£o, esmagamento, amputa√ß√µes, morte.'},
        {'categoria': 'biologico', 'risco': 'V√≠rus, bact√©rias, fungos, parasitas', 'possiveis_danos': 'Infec√ß√µes, doen√ßas, rea√ß√µes al√©rgicas.'},
        {'categoria': 'ergonomico', 'risco': 'Posturas inadequadas', 'possiveis_danos': 'Dores musculares, les√µes na coluna, LER/DORT.'},
        {'categoria': 'ergonomico', 'risco': 'Repetitividade', 'possiveis_danos': 'LER/DORT, tendinites, s√≠ndrome do t√∫nel do carpo.'},
        {'categoria': 'ergonomico', 'risco': 'Levantamento e transporte manual de peso', 'possiveis_danos': 'Les√µes musculoesquel√©ticas, dores na coluna.'},
        {'categoria': 'fisico', 'risco': 'Ru√≠do (cont√≠nuo ou intermitente)', 'possiveis_danos': 'Perda auditiva, zumbido, estresse, irritabilidade.'},
        {'categoria': 'fisico', 'risco': 'Vibra√ß√£o (corpo inteiro)', 'possiveis_danos': 'Problemas na coluna, dores lombares.'},
        {'categoria': 'fisico', 'risco': 'Vibra√ß√£o (m√£os e bra√ßos)', 'possiveis_danos': 'Doen√ßas osteomusculares, problemas circulat√≥rios.'},
        {'categoria': 'fisico', 'risco': 'Calor', 'possiveis_danos': 'Desidrata√ß√£o, insola√ß√£o, c√£ibras, exaust√£o, interma√ß√£o.'},
        {'categoria': 'fisico', 'risco': 'Frio', 'possiveis_danos': 'Hipotermia, congelamento, doen√ßas respirat√≥rias.'},
        {'categoria': 'fisico', 'risco': 'Radia√ß√µes ionizantes', 'possiveis_danos': 'C√¢ncer, muta√ß√µes gen√©ticas, queimaduras.'},
        {'categoria': 'fisico', 'risco': 'Radia√ß√µes n√£o ionizantes', 'possiveis_danos': 'Queimaduras, les√µes oculares, c√¢ncer de pele.'},
        {'categoria': 'fisico', 'risco': 'Press√µes anormais', 'possiveis_danos': 'Doen√ßa descompressiva, barotrauma.'},
        {'categoria': 'fisico', 'risco': 'Umidade', 'possiveis_danos': 'Doen√ßas respirat√≥rias, dermatites, micoses.'},
        {'categoria': 'quimico', 'risco': 'Poeiras', 'possiveis_danos': 'Pneumoconioses (silicose, asbestose), irrita√ß√£o respirat√≥ria.'},
        {'categoria': 'quimico', 'risco': 'Fumos', 'possiveis_danos': 'Doen√ßas respirat√≥rias (febre dos fumos met√°licos), intoxica√ß√µes.'},
        {'categoria': 'quimico', 'risco': 'N√©voas', 'possiveis_danos': 'Irrita√ß√£o respirat√≥ria, dermatites.'},
        {'categoria': 'quimico', 'risco': 'Gases', 'possiveis_danos': 'Asfixia, intoxica√ß√µes, irrita√ß√£o respirat√≥ria.'},
        {'categoria': 'quimico', 'risco': 'Vapores', 'possiveis_danos': 'Irrita√ß√£o respirat√≥ria, intoxica√ß√µes, dermatites.'},
        {'categoria': 'quimico', 'risco': 'Produtos qu√≠micos em geral', 'possiveis_danos': 'Queimaduras, irrita√ß√µes, intoxica√ß√µes, dermatites, c√¢ncer.'},
        {'categoria': 'acidente', 'risco': 'Animais pe√ßonhentos e insetos', 'possiveis_danos': 'Ferimento, corte, contus√£o, rea√ß√£o al√©rgica, infec√ß√£o, morte.'},
        {'categoria': 'acidente', 'risco': 'Atropelamento', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Batida contra', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Choque el√©trico', 'possiveis_danos': 'Queimadura de 1¬∫, 2¬∫ ou 3¬∫ grau, fibrila√ß√£o ventricular, morte.'},
        {'categoria': 'acidente', 'risco': 'Contato com o sistema el√©trico energizado.', 'possiveis_danos': 'Queimadura de 1¬∫, 2¬∫ ou 3¬∫ grau, fibrila√ß√£o ventricular, morte.'},
        {'categoria': 'acidente', 'risco': 'Contato com ferramentas cortantes e/ou perfurantes.', 'possiveis_danos': 'Corte, lacera√ß√£o, ferida contusa, punctura (ferida aberta), perfura√ß√£o.'},
        {'categoria': 'acidente', 'risco': 'Contato com partes m√≥veis de m√°quinas e equipamentos.', 'possiveis_danos': 'Prensamento ou aprisionamento de partes do corpo, cortes, escoria√ß√µes, luxa√ß√µes, fraturas, amputa√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Contato com produtos qu√≠micos.', 'possiveis_danos': 'Intoxica√ß√£o, envenenamento, queimadura, irrita√ß√£o ou rea√ß√£o al√©rgica.'},
        {'categoria': 'acidente', 'risco': 'Contato com subst√¢ncia c√°ustica, t√≥xica ou nociva.', 'possiveis_danos': 'Intoxica√ß√£o, envenenamento, queimadura, irrita√ß√£o ou rea√ß√£o al√©rgica.'},
        {'categoria': 'acidente', 'risco': 'Ingest√£o de subst√¢ncia c√°ustica, t√≥xica ou nociva.', 'possiveis_danos': 'Intoxica√ß√£o, envenenamento, queimadura, irrita√ß√£o ou rea√ß√£o al√©rgica.'},
        {'categoria': 'acidente', 'risco': 'Inala√ß√£o, ingest√£o e/ou absor√ß√£o.', 'possiveis_danos': 'Intoxica√ß√£o, envenenamento, queimadura, irrita√ß√£o ou rea√ß√£o al√©rgica.'},
        {'categoria': 'acidente', 'risco': 'Inc√™ndio/Explos√£o', 'possiveis_danos': 'Queimadura de 1¬∫, 2¬∫ ou 3¬∫ grau, asfixia,  arremessos, cortes, escoria√ß√µes, luxa√ß√µes, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Objetos cortantes/perfurocortantes', 'possiveis_danos': 'Corte, lacera√ß√£o, ferida contusa, punctura (ferida aberta), perfura√ß√£o.'},
        {'categoria': 'acidente', 'risco': 'Pessoas n√£o autorizadas e/ou visitantes no local de trabalho', 'possiveis_danos': 'Escoria√ß√£o, ferimento, corte, luxa√ß√£o, fratura, entre outros danos devido √†s caracter√≠sticas do local e atividades realizadas.'},
        {'categoria': 'acidente', 'risco': 'Portas, escotilhas, tampas, "bocas de visita", flanges', 'possiveis_danos': 'Prensamento ou aprisionamento de partes do corpo, cortes, escoria√ß√µes, luxa√ß√µes, fraturas, amputa√ß√µes, exposi√ß√£o √† gases t√≥xicos.'},
        {'categoria': 'acidente', 'risco': 'Proje√ß√£o de Part√≠culas s√≥lidas e/ou l√≠quidas', 'possiveis_danos': 'Ferimento, corte, queimadura, perfura√ß√£o, intoxica√ß√£o.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel de andaime, passarela, plataforma, etc.', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel de escada (m√≥vel ou fixa).', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel de material empilhado.', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel de ve√≠culo.', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel em po√ßo, escava√ß√£o, abertura no piso, etc.', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel ‚â§ 2m', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa com diferen√ßa de n√≠vel > 2m', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas, morte.'},
        {'categoria': 'acidente', 'risco': 'Queda de pessoa em mesmo n√≠vel', 'possiveis_danos': 'Escoria√ß√µes, ferimentos, cortes, luxa√ß√µes, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Rea√ß√£o do corpo a seus movimentos (escorreg√£o sem queda, etc.)', 'possiveis_danos': 'Tor√ß√µes, distens√ß√µes, rupturas ou outras les√µes musculares internas.'},
        {'categoria': 'acidente', 'risco': 'Vidro (recipientes, portas, bancadas, janelas, objetos diversos).', 'possiveis_danos': 'Corte, ferimento, perfura√ß√£o.'},
        {'categoria': 'acidente', 'risco': 'Soterramento', 'possiveis_danos': 'Asfixia, desconforto respirat√≥rio, n√≠vel de consci√™ncia alterado, letargia, palidez, pele azulada, tosse, transtorno neurol√≥gico.'},
        {'categoria': 'acidente', 'risco': 'Subst√¢ncias t√≥xicas e/ou inflam√°veis', 'possiveis_danos': 'Intoxica√ß√£o, asfixia, queimaduras de  1¬∫, 2¬∫ ou 3¬∫ grau.'},
        {'categoria': 'acidente', 'risco': 'Superf√≠cies, subst√¢ncias e/ou objetos aquecidos ', 'possiveis_danos': 'Queimadura de 1¬∫, 2¬∫ ou 3¬∫ grau.'},
        {'categoria': 'acidente', 'risco': 'Superf√≠cies, subst√¢ncias e/ou objetos em baixa temperatura ', 'possiveis_danos': 'Queimadura de 1¬∫, 2¬∫ ou 3¬∫ grau.'},
        {'categoria': 'acidente', 'risco': 'Tombamento, quebra e/ou ruptura de estrutura (fixa ou m√≥vel)', 'possiveis_danos': 'Prensamento ou aprisionamento de partes do corpo, cortes, escoria√ß√µes, luxa√ß√µes, fraturas, amputa√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Tombamento de m√°quina/equipamento', 'possiveis_danos': 'Prensamento ou aprisionamento de partes do corpo, cortes, escoria√ß√µes, luxa√ß√µes, fraturas, amputa√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Trabalho √† c√©u aberto', 'possiveis_danos': 'Interma√ß√£o, insola√ß√£o, c√£ibra, exaust√£o, desidrata√ß√£o, resfriados.'},
        {'categoria': 'acidente', 'risco': 'Trabalho em espa√ßos confinados', 'possiveis_danos': 'Asfixia, hiper√≥xia, contamina√ß√£o por poeiras e/ou gases t√≥xicos, queimadura de 1¬∫, 2¬∫ ou 3¬∫ grau, arremessos, cortes, escoria√ß√µes, luxa√ß√µes, fraturas.'},
        {'categoria': 'acidente', 'risco': 'Trabalho com m√°quinas port√°teis rotativas.', 'possiveis_danos': 'Cortes, ferimentos, escoria√ß√µes, amputa√ß√µes.'},
        {'categoria': 'acidente', 'risco': 'Trabalho com m√°quinas e/ou equipamentos', 'possiveis_danos': 'Prensamento ou aprisionamento de partes do corpo, cortes, escoria√ß√µes, luxa√ß√µes, fraturas, amputa√ß√µes, choque el√©trico.'}
    ]
    return pd.DataFrame(data)

def substituir_placeholders(doc, contexto):
    """
    Substitui placeholders preservando a formata√ß√£o do template.
    """
    def aplicar_formatacao_padrao(run):
        """Aplica formata√ß√£o Segoe UI 9pt"""
        run.font.name = 'Segoe UI'
        run.font.size = Pt(9)
        return run

    def processar_paragrafo(p):
        texto_original_paragrafo = p.text

        # --- L√≥gica CORRIGIDA E MANTIDA para [MEDI√á√ïES] ---
        if "[MEDI√á√ïES]" in texto_original_paragrafo:
            for run in p.runs:
                run.text = ''
            p.alignment = WD_ALIGN_PARAGRAPH.LEFT
            medicoes_valor = contexto.get("[MEDI√á√ïES]", "N√£o aplic√°vel")
            if medicoes_valor == "N√£o aplic√°vel" or not medicoes_valor.strip():
                run = aplicar_formatacao_padrao(p.add_run("N√£o aplic√°vel"))
                run.font.bold = False
            else:
                linhas = medicoes_valor.split('\n')
                for i, linha in enumerate(linhas):
                    if not linha.strip(): continue
                    if i > 0: p.add_run().add_break()
                    if ":" in linha:
                        partes = linha.split(":", 1)
                        agente_texto = partes[0].strip() + ":"
                        valor_texto = partes[1].strip()
                        run_agente = aplicar_formatacao_padrao(p.add_run(agente_texto + " "))
                        run_agente.font.bold = True
                        run_valor = aplicar_formatacao_padrao(p.add_run(valor_texto))
                        run_valor.font.bold = False
                    else:
                        run_simples = aplicar_formatacao_padrao(p.add_run(linha))
                        run_simples.font.bold = False
            return

        # --- L√≥gica RESTAURADA E CORRIGIDA para outros placeholders ---
        placeholders_no_paragrafo = [key for key in contexto if key in texto_original_paragrafo]
        if not placeholders_no_paragrafo:
            return

        # Preserva o estilo do primeiro 'run', que geralmente define o estilo do r√≥tulo no template
        estilo_rotulo = {
            'bold': p.runs[0].bold if p.runs else False,
            'italic': p.runs[0].italic if p.runs else False,
            'underline': p.runs[0].underline if p.runs else False,
        }

        # Substitui todos os placeholders para obter o texto final
        texto_final = texto_original_paragrafo
        for key in placeholders_no_paragrafo:
            texto_final = texto_final.replace(key, str(contexto[key]))
        
        # Limpa o par√°grafo para reescrev√™-lo com a formata√ß√£o correta
        p.clear()

        # Reconstr√≥i o par√°grafo, aplicando o estilo do r√≥tulo e deixando os valores sem formata√ß√£o
        texto_restante = texto_final
        for i, key in enumerate(placeholders_no_paragrafo):
            valor_placeholder = str(contexto[key])
            partes = texto_restante.split(valor_placeholder, 1)
            
            # Adiciona o texto antes do valor (que √© o r√≥tulo) com o estilo preservado
            if partes[0]:
                run_rotulo = aplicar_formatacao_padrao(p.add_run(partes[0]))
                run_rotulo.font.bold = estilo_rotulo['bold']
                run_rotulo.font.italic = estilo_rotulo['italic']
                run_rotulo.underline = estilo_rotulo['underline']

            # Adiciona o valor do placeholder sem formata√ß√£o
            run_valor = aplicar_formatacao_padrao(p.add_run(valor_placeholder))
            run_valor.font.bold = False
            run_valor.font.italic = False
            run_valor.font.underline = False
            
            texto_restante = partes[1]

        # Adiciona qualquer texto que sobrar no final, com o estilo do r√≥tulo
        if texto_restante:
            run_final = aplicar_formatacao_padrao(p.add_run(texto_restante))
            run_final.font.bold = estilo_rotulo['bold']
            run_final.font.italic = estilo_rotulo['italic']
            run_final.underline = estilo_rotulo['underline']

    # Processar par√°grafos em tabelas e no corpo do documento
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                for p in cell.paragraphs:
                    processar_paragrafo(p)
    for p in doc.paragraphs:
        processar_paragrafo(p)


def gerar_os(funcionario, df_pgr, riscos_selecionados, epis_manuais, medicoes_manuais, riscos_manuais, modelo_doc_carregado):
    doc = Document(modelo_doc_carregado)
    riscos_info = df_pgr[df_pgr['risco'].isin(riscos_selecionados)]
    riscos_por_categoria = {cat: [] for cat in CATEGORIAS_RISCO.keys()}
    danos_por_categoria = {cat: [] for cat in CATEGORIAS_RISCO.keys()}

    # Processar riscos selecionados
    for _, risco_row in riscos_info.iterrows():
        categoria = str(risco_row.get("categoria", "")).lower()
        if categoria in riscos_por_categoria:
            riscos_por_categoria[categoria].append(str(risco_row.get("risco", "")))
            danos = risco_row.get("possiveis_danos")
            if pd.notna(danos): 
                danos_por_categoria[categoria].append(str(danos))

    # Processar riscos manuais
    if riscos_manuais:
        map_categorias_rev = {v: k for k, v in CATEGORIAS_RISCO.items()}
        for risco_manual in riscos_manuais:
            categoria_display = risco_manual.get('category')
            categoria_alvo = map_categorias_rev.get(categoria_display)
            if categoria_alvo:
                riscos_por_categoria[categoria_alvo].append(risco_manual.get('risk_name', ''))
                if risco_manual.get('possible_damages'):
                    danos_por_categoria[categoria_alvo].append(risco_manual.get('possible_damages'))

    # Limpar duplicatas
    for cat in danos_por_categoria:
        danos_por_categoria[cat] = sorted(list(set(danos_por_categoria[cat])))

    # FORMATA√á√ÉO SIMPLES DAS MEDI√á√ïES
    medicoes_formatadas = []
    for med in medicoes_manuais:
        agente = str(med.get('agent', '')).strip()
        valor = str(med.get('value', '')).strip()
        unidade = str(med.get('unit', '')).strip()
       
        if agente and agente not in ['', 'N/A', 'nan', 'None'] and valor and valor not in ['', 'N/A', 'nan', 'None']:
            linha = f"{agente}: {valor}"
            if unidade and unidade not in ['', 'N/A', 'nan', 'None']:
                linha += f" {unidade}"
            if epi and epi not in ['', 'N/A', 'nan', 'None']:
                linha += f" | EPI: {epi}"
            medicoes_formatadas.append(linha)
    medicoes_texto = "\n".join(medicoes_formatadas) if medicoes_formatadas else "N√£o aplic√°vel"

    # Processar data de admiss√£o
    data_admissao = "N√£o informado"
    if 'data_de_admissao' in funcionario and pd.notna(funcionario['data_de_admissao']):
        try: 
            data_admissao = pd.to_datetime(funcionario['data_de_admissao']).strftime('%d/%m/%Y')
        except Exception: 
            data_admissao = str(funcionario['data_de_admissao'])
    elif 'Data de Admiss√£o' in funcionario and pd.notna(funcionario['Data de Admiss√£o']):
        try: 
            data_admissao = pd.to_datetime(funcionario['Data de Admiss√£o']).strftime('%d/%m/%Y')
        except Exception: 
            data_admissao = str(funcionario['Data de Admiss√£o'])

    # Processar descri√ß√£o de atividades
    descricao_atividades = "N√£o informado"
    if 'descricao_de_atividades' in funcionario and pd.notna(funcionario['descricao_de_atividades']):
        descricao_atividades = str(funcionario['descricao_de_atividades']).strip()
    elif 'Descri√ß√£o de Atividades' in funcionario and pd.notna(funcionario['Descri√ß√£o de Atividades']):
        descricao_atividades = str(funcionario['Descri√ß√£o de Atividades']).strip()

    if descricao_atividades == "N√£o informado" or descricao_atividades == "" or descricao_atividades == "nan":
        funcao = str(funcionario.get('funcao', funcionario.get('Fun√ß√£o', 'N/A')))
        setor = str(funcionario.get('setor', funcionario.get('Setor', 'N/A')))
        if funcao != 'N/A' and setor != 'N/A':
            descricao_atividades = f"Atividades relacionadas √† fun√ß√£o de {funcao} no setor {setor}, incluindo todas as tarefas operacionais, administrativas e de apoio inerentes ao cargo."
        else:
            descricao_atividades = "Atividades operacionais, administrativas e de apoio conforme definido pela chefia imediata."

    def tratar_lista_vazia(lista, separador=", "):
        if not lista or all(not item.strip() for item in lista): 
            return "N√£o identificado"
        return separador.join(sorted(list(set(item for item in lista if item and item.strip()))))

    # Contexto
    contexto = {
        "[NOME EMPRESA]": str(funcionario.get("empresa", funcionario.get("Empresa", "N/A"))), 
        "[UNIDADE]": str(funcionario.get("unidade", funcionario.get("Unidade", "N/A"))),
        "[NOME FUNCION√ÅRIO]": str(funcionario.get("nome_do_funcionario", funcionario.get("Nome", "N/A"))), 
        "[DATA DE ADMISS√ÉO]": data_admissao,
        "[SETOR]": str(funcionario.get("setor", funcionario.get("Setor", "N/A"))), 
        "[FUN√á√ÉO]": str(funcionario.get("funcao", funcionario.get("Fun√ß√£o", "N/A"))),
        "[DESCRI√á√ÉO DE ATIVIDADES]": descricao_atividades,
        "[RISCOS F√çSICOS]": tratar_lista_vazia(riscos_por_categoria["fisico"]),
        "[RISCOS DE ACIDENTE]": tratar_lista_vazia(riscos_por_categoria["acidente"]),
        "[RISCOS QU√çMICOS]": tratar_lista_vazia(riscos_por_categoria["quimico"]),
        "[RISCOS BIOL√ìGICOS]": tratar_lista_vazia(riscos_por_categoria["biologico"]),
        "[RISCOS ERGON√îMICOS]": tratar_lista_vazia(riscos_por_categoria["ergonomico"]),
        "[POSS√çVEIS DANOS RISCOS F√çSICOS]": tratar_lista_vazia(danos_por_categoria["fisico"], "; "),
        "[POSS√çVEIS DANOS RISCOS ACIDENTE]": tratar_lista_vazia(danos_por_categoria["acidente"], "; "),
        "[POSS√çVEIS DANOS RISCOS QU√çMICOS]": tratar_lista_vazia(danos_por_categoria["quimico"], "; "),
        "[POSS√çVEIS DANOS RISCOS BIOL√ìGICOS]": tratar_lista_vazia(danos_por_categoria["biologico"], "; "),
        "[POSS√çVEIS DANOS RISCOS ERGON√îMICOS]": tratar_lista_vazia(danos_por_categoria["ergonomico"], "; "),
        "[EPIS]": tratar_lista_vazia([epi['epi_name'] for epi in epis_manuais]),
        "[MEDI√á√ïES]": medicoes_texto,
    }

    substituir_placeholders(doc, contexto)
    return doc

# --- APLICA√á√ÉO PRINCIPAL ---
def main():
    check_authentication()
    init_user_session_state()
    
    if not st.session_state.get('authenticated'):
        show_login_page()
        return
    
    user_id = st.session_state.user_data['user_id']
    show_user_info()
    
    st.markdown("""<div class="main-header"><h1>üìÑ Gerador de Ordens de Servi√ßo (OS)</h1><p>Gere OS em lote a partir de um modelo Word (.docx) e uma planilha de funcion√°rios.</p></div>""", unsafe_allow_html=True)

    with st.container(border=True):
        st.markdown("##### üìÇ 1. Carregue os Documentos")
        col1, col2 = st.columns(2)
        with col1:
            arquivo_funcionarios = st.file_uploader("üìÑ **Planilha de Funcion√°rios (.xlsx)**", type="xlsx")
        with col2:
            arquivo_modelo_os = st.file_uploader("üìù **Modelo de OS (.docx)**", type="docx")

    if not arquivo_funcionarios or not arquivo_modelo_os:
        st.info("üìã Por favor, carregue a Planilha de Funcion√°rios e o Modelo de OS para continuar.")
        return
    
    df_funcionarios_raw = carregar_planilha(arquivo_funcionarios)
    if df_funcionarios_raw is None:
        st.stop()

    df_funcionarios = mapear_e_renomear_colunas_funcionarios(df_funcionarios_raw)
    df_pgr = obter_dados_pgr()

    with st.container(border=True):
        st.markdown('##### üë• 2. Selecione os Funcion√°rios')
        setores = sorted(df_funcionarios['setor'].dropna().unique().tolist()) if 'setor' in df_funcionarios.columns else []
        setor_sel = st.multiselect("Filtrar por Setor(es)", setores)
        df_filtrado_setor = df_funcionarios[df_funcionarios['setor'].isin(setor_sel)] if setor_sel else df_funcionarios
        st.caption(f"{len(df_filtrado_setor)} funcion√°rio(s) no(s) setor(es) selecionado(s).")
        funcoes_disponiveis = sorted(df_filtrado_setor['funcao'].dropna().unique().tolist()) if 'funcao' in df_filtrado_setor.columns else []
        funcoes_formatadas = []
        if setor_sel:
            for funcao in funcoes_disponiveis:
                concluido = all((s, funcao) in st.session_state.cargos_concluidos for s in setor_sel)
                if concluido:
                    funcoes_formatadas.append(f"{funcao} ‚úÖ Conclu√≠do")
                else:
                    funcoes_formatadas.append(funcao)
        else:
            funcoes_formatadas = funcoes_disponiveis
        funcao_sel_formatada = st.multiselect("Filtrar por Fun√ß√£o/Cargo(s)", funcoes_formatadas)
        funcao_sel = [f.replace(" ‚úÖ Conclu√≠do", "") for f in funcao_sel_formatada]
        df_final_filtrado = df_filtrado_setor[df_filtrado_setor['funcao'].isin(funcao_sel)] if funcao_sel else df_filtrado_setor
        st.success(f"**{len(df_final_filtrado)} funcion√°rio(s) selecionado(s) para gerar OS.**")
        st.dataframe(df_final_filtrado[['nome_do_funcionario', 'setor', 'funcao']])

    with st.container(border=True):
        st.markdown('##### ‚ö†Ô∏è 3. Configure os Riscos e Medidas de Controle')
        st.info("Os riscos configurados aqui ser√£o aplicados a TODOS os funcion√°rios selecionados.")
        riscos_selecionados = []
        nomes_abas = list(CATEGORIAS_RISCO.values()) + ["‚ûï Manual"]
        tabs = st.tabs(nomes_abas)
        for i, (categoria_key, categoria_nome) in enumerate(CATEGORIAS_RISCO.items()):
            with tabs[i]:
                riscos_da_categoria = df_pgr[df_pgr['categoria'] == categoria_key]['risco'].tolist()
                selecionados = st.multiselect("Selecione os riscos:", options=riscos_da_categoria, key=f"riscos_{categoria_key}")
                riscos_selecionados.extend(selecionados)
        with tabs[-1]:
            with st.form("form_risco_manual", clear_on_submit=True):
                st.markdown("###### Adicionar um Risco que n√£o est√° na lista")
                risco_manual_nome = st.text_input("Descri√ß√£o do Risco")
                categoria_manual = st.selectbox("Categoria do Risco Manual", list(CATEGORIAS_RISCO.values()))
                danos_manuais = st.text_area("Poss√≠veis Danos (Opcional)")
                if st.form_submit_button("Adicionar Risco Manual"):
                    if risco_manual_nome and categoria_manual:
                        user_data_manager.add_manual_risk(user_id, categoria_manual, risco_manual_nome, danos_manuais)
                        st.session_state.user_data_loaded = False
                        st.rerun()
            if st.session_state.riscos_manuais_adicionados:
                st.write("**Riscos manuais salvos:**")
                for r in st.session_state.riscos_manuais_adicionados:
                    col1, col2 = st.columns([4, 1])
                    col1.markdown(f"- **{r['risk_name']}** ({r['category']})")
                    if col2.button("Remover", key=f"rem_risco_{r['id']}"):
                        user_data_manager.remove_manual_risk(user_id, r['id'])
                        st.session_state.user_data_loaded = False
                        st.rerun()
        
        total_riscos = len(riscos_selecionados) + len(st.session_state.riscos_manuais_adicionados)
        if total_riscos > 0:
            with st.expander(f"üìñ Resumo de Riscos Selecionados ({total_riscos} no total)", expanded=True):
                riscos_para_exibir = {cat: [] for cat in CATEGORIAS_RISCO.values()}
                for risco_nome in riscos_selecionados:
                    categoria_key_series = df_pgr[df_pgr['risco'] == risco_nome]['categoria']
                    if not categoria_key_series.empty:
                        categoria_key = categoria_key_series.iloc[0]
                        categoria_display = CATEGORIAS_RISCO.get(categoria_key)
                        if categoria_display:
                            riscos_para_exibir[categoria_display].append(risco_nome)
                for risco_manual in st.session_state.riscos_manuais_adicionados:
                    riscos_para_exibir[risco_manual['category']].append(risco_manual['risk_name'])
                for categoria, lista_riscos in riscos_para_exibir.items():
                    if lista_riscos:
                        st.markdown(f"**{categoria}**")
                        for risco in sorted(list(set(lista_riscos))):
                            st.markdown(f"- {risco}")
        
        st.divider()

        col_exp1, col_exp2 = st.columns(2)
        with col_exp1:
            with st.expander("üìä **Adicionar Medi√ß√µes**"):
                with st.form("form_medicao", clear_on_submit=True):
                    opcoes_agente = ["-- Digite um novo agente abaixo --"] + AGENTES_DE_RISCO
                    agente_selecionado = st.selectbox("Selecione um Agente/Fonte da lista...", options=opcoes_agente)
                    agente_manual = st.text_input("...ou digite um novo aqui:")
                    valor = st.text_input("Valor Medido")
                    unidade = st.selectbox("Unidade", UNIDADES_DE_MEDIDA)
                    epi_med = st.text_input("EPI Associado (Opcional)")
                    if st.form_submit_button("Adicionar Medi√ß√£o"):
                        agente_a_salvar = agente_manual.strip() if agente_manual.strip() else agente_selecionado
                        if agente_a_salvar != "-- Digite um novo agente abaixo --" and valor:
                            user_data_manager.add_measurement(user_id, agente_a_salvar, valor, unidade, epi_med)
                            st.session_state.user_data_loaded = False
                            st.rerun()
                        else:
                            st.warning("Por favor, preencha o Agente e o Valor.")
                if st.session_state.medicoes_adicionadas:
                    st.write("**Medi√ß√µes salvas:**")
                    for med in st.session_state.medicoes_adicionadas:
                        col1, col2 = st.columns([4, 1])
                        col1.markdown(f"- {med['agent']}: {med['value']} {med['unit']}")
                        if col2.button("Remover", key=f"rem_med_{med['id']}"):
                            user_data_manager.remove_measurement(user_id, med['id'])
                            st.session_state.user_data_loaded = False
                            st.rerun()
        with col_exp2:
            with st.expander("ü¶∫ **Adicionar EPIs Gerais**"):
                with st.form("form_epi", clear_on_submit=True):
                    epi_nome = st.text_input("Nome do EPI")
                    if st.form_submit_button("Adicionar EPI"):
                        if epi_nome:
                            user_data_manager.add_epi(user_id, epi_nome)
                            st.session_state.user_data_loaded = False
                            st.rerun()
                if st.session_state.epis_adicionados:
                    st.write("**EPIs salvos:**")
                    for epi in st.session_state.epis_adicionados:
                        col1, col2 = st.columns([4, 1])
                        col1.markdown(f"- {epi['epi_name']}")
                        if col2.button("Remover", key=f"rem_epi_{epi['id']}"):
                            user_data_manager.remove_epi(user_id, epi['id'])
                            st.session_state.user_data_loaded = False
                            st.rerun()

    st.divider()
    if st.button("üöÄ Gerar OS para Funcion√°rios Selecionados", type="primary", use_container_width=True, disabled=df_final_filtrado.empty):
        with st.spinner(f"Gerando {len(df_final_filtrado)} documentos..."):
            documentos_gerados = []
            combinacoes_processadas = set()
            for _, func in df_final_filtrado.iterrows():
                combinacoes_processadas.add((func['setor'], func['funcao']))
                doc = gerar_os(
                    func, 
                    df_pgr, 
                    riscos_selecionados, 
                    st.session_state.epis_adicionados,
                    st.session_state.medicoes_adicionadas, 
                    st.session_state.riscos_manuais_adicionados, 
                    arquivo_modelo_os
                )
                doc_io = BytesIO()
                doc.save(doc_io)
                doc_io.seek(0)
                nome_limpo = re.sub(r'[^\w\s-]', '', func.get("nome_do_funcionario", "Func_Sem_Nome")).strip().replace(" ", "_")
                caminho_no_zip = f"{func.get('setor', 'SemSetor')}/{func.get('funcao', 'SemFuncao')}/OS_{nome_limpo}.docx"
                documentos_gerados.append((caminho_no_zip, doc_io.getvalue()))
            st.session_state.cargos_concluidos.update(combinacoes_processadas)
            if documentos_gerados:
                zip_buffer = BytesIO()
                with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                    for nome_arquivo, conteudo_doc in documentos_gerados:
                        zip_file.writestr(nome_arquivo, conteudo_doc)
                nome_arquivo_zip = f"OS_Geradas_{time.strftime('%Y%m%d')}.zip"
                st.success(f"üéâ **{len(documentos_gerados)} Ordens de Servi√ßo geradas!**")
                st.download_button(
                    label="üì• Baixar Todas as OS (.zip)", 
                    data=zip_buffer.getvalue(), 
                    file_name=nome_arquivo_zip, 
                    mime="application/zip",
                    use_container_width=True
                )

if __name__ == "__main__":
    main()
